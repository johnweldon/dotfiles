#!/usr/bin/env bash

## Usage: execute_remote_command "command" "host1" "host2" ...
#
# Example
#
# updated="${1:?missing token}"
# hosts=(host1 host2)
#
# remote_command=$(
#  cat <<EOF
#  grep -qs 'GITHUB_TOKEN' ~/.local.bashrc && (
#    grep -qs 'GITHUB_TOKEN=${updated}' ~/.local.bashrc && (
#      echo "already up to date"
#    ) || (
#      echo "updating"
#      sed -i.bak -e 's/export GITHUB_TOKEN=.*/export GITHUB_TOKEN=${updated}/g' ~/.local.bashrc
#    )
#  ) || echo "skipping"
# EOF
#)
#
# execute_remote_command "${remote_command}" "${hosts[@]}"

function execute_remote_command {
  local remote_command="${1:-uptime}"
  shift || :
  local remote_hosts=("$@")
  local pids=()

  local keychain_init="${HOME}/.keychain/${HOSTNAME}-sh"
  # shellcheck disable=SC1090
  [ -f "${keychain_init}" ] && source "${keychain_init}"

  # Detect color support
  local use_color=0
  if [[ -z "${NO_COLOR:-}" ]] && [[ "${TERM:-}" != "dumb" ]] && { [[ -t 1 ]] || [[ -t 2 ]]; }; then
    use_color=1
  fi

  # Set color codes based on terminal support
  local dim_white="" green="" dim_red="" reset=""
  if [[ $use_color -eq 1 ]]; then
    dim_white="\033[2;37m"
    green="\033[32m"
    dim_red="\033[2;31m"
    reset="\033[0m"
  fi

  # Calculate maximum hostname length for alignment
  local max_width=0
  for rhost in "${remote_hosts[@]}"; do
    local len=${#rhost}
    [[ $len -gt $max_width ]] && max_width=$len
  done

  echo "Executing: cmd on ${remote_hosts[*]}"
  for rhost in "${remote_hosts[@]}"; do
    {
      ssh -A -T -q "${rhost}" "${remote_command}" \
        2> >(awk -v pfx="${rhost}" -v width="${max_width}" -v dw="${dim_white}" -v dr="${dim_red}" -v rs="${reset}" \
          '{printf "%s%*s%s %sXX %s%s\n", dw, width, pfx, rs, dr, $0, rs}' >&2) ||
        echo "${rhost} connect error $?" |
        awk -v pfx="${rhost}" -v width="${max_width}" -v dw="${dim_white}" -v dr="${dim_red}" -v rs="${reset}" \
          '{printf "%s%*s%s %sXX %s%s\n", dw, width, pfx, rs, dr, $0, rs}' >&2
    } |
      awk -v pfx="${rhost}" -v width="${max_width}" -v dw="${dim_white}" -v g="${green}" -v rs="${reset}" \
        '{printf "%s%*s%s %s::%s %s\n", dw, width, pfx, rs, g, rs, $0}' &
    pids+=($!)
  done

  for pid in "${pids[@]}"; do
    wait "$pid"
  done
}

## Usage: get_srv_hostnames [-s dns_server] "service"
#
# Example
#
# mapfile -t hosts < <(get_srv_hostnames "_http._tcp.example.com")
# mapfile -t hosts < <(get_srv_hostnames -s "8.8.8.8" "_http._tcp.example.com")
# execute_remote_command "uptime" "${hosts[@]}"

function get_srv_hostnames {
  local dns_server=""
  local service=""
  local OPTIND

  while getopts "s:" opt; do
    case $opt in
    s)
      dns_server="$OPTARG"
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      return 1
      ;;
    esac
  done
  shift $((OPTIND - 1))

  service="${1:?missing service}"

  if [[ -n "$dns_server" ]]; then
    dig +short SRV "@${dns_server}" "${service}"
  else
    dig +short SRV "${service}"
  fi |
    awk '{print $4}' |
    sed 's/\.$//g' |
    grep -v '^$'
}
